const fetch = resource =>
  fs.readFileSync (resource, `utf-8`)

const { JSDOM } = require (`jsdom`)
  , fs = require (`fs`)
  , item = `Foo`
  , script = './elements/template.js'
  , template = fetch (`./index.html`)
  , element = `<ul id='items'>\n\n</ul>\n\n${template}\n\n`

var configuration = {
//html: element,
//scripts: [script],
//url: 'http://foo.bar.com',
// file: a file which jsdom will load HTML from; the resulting document's URL will be a file:// URL,
//src: src
}

configuration.done = (error, window) => {
//console.warn (window.document.querySelector ('template#item').innerHTML)
  console.warn ('Document inner html\n\n', window.document.documentElement.innerHTML)

  window.close ()
}

configuration.created = (error, window) => {
  console.log ('\n\n\nWindow.created: Modify `window` object (e.g. add new functions on built-in prototypes before any scripts execute')
}

configuration.onload  = (window) => {
  console.log ('\nWindow.onload: Only called if creation succeeds without error\n')
}

//import { test, expect } from 'node:test';

// https://github.com/tmpvar/jsdom/issues/317
// https://github.com/w3c/web-platform-tests/tree/master/dom/traversal

const n = require('node:test')
, it = n.it // test
, test = n.test
, mock = n.mock
, skip = it.skip
, todo = it.todo
, only = it.only
, after = n.afterEach
, before = n.beforeEach
, describe = n.describe
, assert = require ('assert')

// https://nodejs.org/api/test.html#class-suitecontext
describe ('Template', t => {
  const node = {}

  test('should add two numbers', _ => {
    const result = 1 + 2
    assert.strictEqual (result, 3)
  })
})

// WARNING! ONLY USE LOCAL SCRIPTS
// https://github.com/tmpvar/jsdom#user-content-for-the-hardcore-jsdomjsdom
// The jsdom.jsdom method does fewer things automatically; it takes in only HTML source, and it does not allow you to separately supply scripts that it will inject and execute. It just gives you back a document object, with usable document.defaultView, and starts asynchronously executing any <script>s included in the HTML source. You can listen for the 'load' event to wait until scripts are done loading and executing, just like you would in a normal HTML page.
//
// Usage of the API generally looks like this:
//
// var jsdom = require("jsdom").jsdom;
// var doc = jsdom(markup, options);
// var window = doc.defaultView;
// dom.jsdom (element, configuration)

const dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`)
console.log( dom.window.document.body.outerHTML ) // "Hello world"

return

var virtualConsole = dom.createVirtualConsole ()
  .sendTo (console)

virtualConsole
  .on (`log`, message => console.log (message))

//dom.jsdom(element, configuration, { virtualConsole })

dom.env(element, configuration, { virtualConsole })
