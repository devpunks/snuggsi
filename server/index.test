//require ('./mount.test')

import assert from 'node:assert/strict'
import { test, describe, mock } from 'node:test'

import Server from './index.es'

//const
//  assert = require ( 'node:assert/strict' )
//, { test, describe, mock } = require ( 'node:test' )
//import { test } from 'node:test'
//import assert from 'node:assert/strict'

//, { readFileSync: read } = require ( 'node:fs' )
//, { test } = require ( '../test/index.es' )

//, Server = require ( './index.es' )


test ( 'new Server does not throw', _ => {
  console.log ( 'Server class: ', Server )
  assert ( new Server )
})

/*
test ('closing server', t => {

  //const
  //  server
  //    = ( new Server ).serve ``


  //server.close ()
})


test ('closing server with backticks', t => {

  //const
  //  server
  //    = ( new Server ).serve ``


  //server.close ``
  //server.close ()
})


test ('closing server by calling with template literal', t => {

  //const
  //  server
  //    = ( new Server ).serve ``


  //server.close ``
  //server.close ()
})


test ('middleware collection dependency injection', t => {

//const
//  middleware = context =>
//    context.set ('test', 'Hello World')

//, stack = [ middleware ]

//  server
//    = ( new Server ( stack ) ).serve `server/fixtures`

//, { headers }
//    = await fetch ( `http://localhost:${process.env.PORT}/` )


//t.equal
//  ( headers.get ('test'), 'Hello World' )

//server.close ``
})


test ('serve defaults to `public` when called without argument', t => {

//const
//  file = 'index.html'

//, server
//    = ( new Server ).serve ('')

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/${file}`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read (`./public/${file}`) )


//  server.close ``
})


test ('serve defaults to `public` when called with empty template literal', t => {

//const
//  file = 'index.html'

//  server
//    = ( new Server ).serve ``

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/${file}`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read (`./public/${file}`) )


//server.close ``
})


test ('serving specific directory', t => {

//const
//  server
//    = ( new Server ).serve ('server/fixtures')

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/index.txt`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read `./server/fixtures/index.txt` )


//server.close ``
})


test ('serving specific directory with template literal', t => {

//const
//  server
//    = ( new Server ).serve `server/fixtures`

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/index.txt`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read `./server/fixtures/index.txt` )


//server.close ``
})
*/
