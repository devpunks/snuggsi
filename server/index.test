//require ('./mount.test')

import assert from 'node:assert/strict'
import { test, describe, mock } from 'node:test'

import Server from './index.es'

//const
//  assert = require ( 'node:assert/strict' )
//, { test, describe, mock } = require ( 'node:test' )
//import { test } from 'node:test'
//import assert from 'node:assert/strict'

//, { readFileSync: read } = require ( 'node:fs' )
//, { test } = require ( '../test/index.es' )

//, Server = require ( './index.es' )


test ( 'new Server does not throw', _ => {
  console.log ( 'Server class: ', Server )
  assert ( new Server )
})

test ('closing server', t => {

  const
    server
      = ( new Server ).serve ``


  server.close ()
})


test ('closing server with backticks', t => {

  const
    server
      = ( new Server ).serve ``


  server.close ``
})

test ('middleware collection dependency injection', async t => {

const
  middleware = context =>
    context.set ('test', 'Hello World')

, stack = [ middleware ]

, server
    = new Server ().serve `` // ( new Server ( stack ) ).serve ``

, { headers }
    = await fetch ( `http:localhost:${process.env.PORT}/` )


  console.log ( 'server', server )
  console.log ( 'headers', headers )
  console.log ( 'link', headers.get ( 'link' )  )
  console.log ( 'CSP', headers.get ( 'content-security-policy-report-only' )  )
//t.equal
//  ( headers.get ('test'), 'Hello World' )

//server.close(() => {
//  console.log('Server closed. Exiting process.');
//  process.exit(0);
//})
})


/*
test ('serve defaults to `public` when called without argument', async t => {

const
  file = 'index.html'

, server
    = ( new Server ).serve ('')

, response
    = await fetch (`http:localhost:${process.env.PORT}/${file}`)


t.equal
  (200, response.status)

t.equal
  ( await response.text ``, await read (`./public/${file}`) )


  server.close ``
})


test ('serve defaults to `public` when called with empty template literal', async t => {

const
  file = 'index.html'

  server
    = ( new Server ).serve ``

, response
    = await fetch (`http:localhost:${process.env.PORT}/${file}`)


t.equal
  (200, response.status)

t.equal
  ( await response.text ``, await read (`./public/${file}`) )


server.close ``
})


test ('serving specific directory', async t => {

//const
//  server
//    = ( new Server ).serve ('server/fixtures')

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/index.txt`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read `./server/fixtures/index.txt` )


//server.close ``
})


test ('serving specific directory with template literal', t => {

//const
//  server
//    = ( new Server ).serve `server/fixtures`

//, response
//    = await fetch (`http://localhost:${process.env.PORT}/index.txt`)


//t.equal
//  (200, response.status)

//t.equal
//  ( await response.text ``, await read `./server/fixtures/index.txt` )


//server.close ``
})
*/
